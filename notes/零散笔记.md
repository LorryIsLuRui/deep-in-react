setState 的算任务，也算更新

> 为什么commit 阶段不能打断？

因为 commit 阶段副作用太多了，如果重新执行会耗费很多时间。

commit阶段要执行componentDidMount这种react完全失控的副作用，以及其它生命周期，当然不能打断，不然打断再运行，岂不是会重复调用多次？
在reconcile阶段，react同样避免调用任何失控的代码，如componentWillReceiveProps，componentWillReceiveProps，用户在这些生命周期里面调用setState，reconcile被打断后重新开始岂不是要调用多次setState？



> 如何给调度任务定优先级？



> 如何中断/断点恢复？

中断：检查当前正在处理的工作单元，保存当前成果（`firstEffect, lastEffect`），修改tag标记一下，迅速收尾并再开一个`requestIdleCallback`，下次有机会再做

断点恢复：下次再处理到该工作单元时，看tag是被打断的任务，接着做未完成的部分或者重做

P.S.无论是时间用尽“自然”中断，还是被高优任务粗暴打断，对中断机制来说都一样



Fiber 架构能够将任务分片，划分优先级，同时能够实现类似于操作系统中对线程的抢占式调度。

> 如何进行抢占式的？



> 如何调度任务？

分2部分：

- 工作循环
- 优先级机制

工作循环是*基本的任务调度机制*，工作循环中每次处理一个任务（工作单元），处理完毕有一次喘息的机会：

```
// Flush asynchronous work until the deadline runs out of time.
while (nextUnitOfWork !== null && !shouldYield()) {
  nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
}
```

`shouldYield`就是看时间用完了没（`idleDeadline.timeRemaining()`），没用完的话继续处理下一个任务，用完了就结束，把时间控制权还给主线程，等下一次`requestIdleCallback`回调再接着做：

```
// If there's work left over, schedule a new callback.
if (nextFlushedExpirationTime !== NoWork) {
  scheduleCallbackWithExpiration(nextFlushedExpirationTime);
}
```

也就是说，（不考虑突发事件的）正常调度是由工作循环来完成的，基本*规则*是：每个工作单元结束检查是否还有时间做下一个，没时间了就先“挂起”

优先级机制用来处理突发事件与优化次序，例如：

- 到commit阶段了，提高优先级
- 高优任务做一半出错了，给降一下优先级
- 抽空关注一下低优任务，别给饿死了
- 如果对应DOM节点此刻不可见，给降到最低优先级

这些策略用来动态调整任务调度，是工作循环的*辅助机制*，最先做最重要的事情

> 如何收集任务结果？

Fiber reconciliation的工作循环具体如下：

1. 找到根节点优先级最高的workInProgress tree，取其待处理的节点（代表组件或DOM节点）
2. 检查当前节点是否需要更新，不需要的话，直接到4
3. 标记一下（打个tag），更新自己（组件更新`props`，`context`等，DOM节点记下DOM change），并为孩子生成workInProgress node
4. 如果没有产生子节点，归并effect list（包含DOM change）到父级
5. 把孩子或兄弟作为待处理节点，准备进入下一个工作循环。如果没有待处理节点（回到了workInProgress tree的根节点），工作循环结束

通过每个节点更新结束时*向上归并effect list*来收集任务结果，reconciliation结束后，根节点的effect list里记录了包括DOM change在内的所有side effect